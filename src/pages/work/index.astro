---
import {getCollection} from "astro:content";
import PageLayout from "@layouts/PageLayout.astro";
import Container from "@components/Container.astro";
import {dateRange} from "@lib/utils";
import {WORK} from "@consts";

const endSortValue = (value) => {
    if (!value) return 0;
    if (typeof value === "string") {
        // "Present" / "Current" / any string should sort after real dates
        return Number.MAX_SAFE_INTEGER;
    }
    // Assume Date
    return new Date(value).valueOf();
};

// Get all work entries, newest start date first
const collection = (await getCollection("work"))
    .sort(
        (a, b) =>
            new Date(b.data.dateStart).valueOf() -
            new Date(a.data.dateStart).valueOf()
    );

// Render MD/MDX content for each entry
const work = await Promise.all(
    collection.map(async (item) => {
        const {Content} = await item.render();
        return {...item, Content};
    })
);

// Group entries by company
const companyMap = new Map();

for (const entry of work) {
    const company = entry.data.company;
    if (!companyMap.has(company)) {
        companyMap.set(company, []);
    }
    companyMap.get(company).push(entry);
}

const groupedWork = Array.from(companyMap.entries())
    .map(([company, entries]) => {
        entries.sort(
            (a, b) =>
                new Date(b.data.dateStart).valueOf() -
                new Date(a.data.dateStart).valueOf()
        );

        const mostRecent = entries[0];
        const oldest = entries[entries.length - 1];

        const companyStart = oldest.data.dateStart;
        const companyEnd = mostRecent.data.dateEnd;

        return {
            company,
            entries,
            companyStart,
            companyEnd,
            mostRecentEnd: mostRecent.data.dateEnd,
        };
    })
    // Sort companies: current roles first, then by most recent end date
    .sort((a, b) => {
        const aEnd = endSortValue(a.mostRecentEnd);
        const bEnd = endSortValue(b.mostRecentEnd);

        if (aEnd !== bEnd) return bEnd - aEnd;

        // fallback: newest start date
        return (
            new Date(b.entries[0].data.dateStart).valueOf() -
            new Date(a.entries[0].data.dateStart).valueOf()
        );
    });
---
<PageLayout title={WORK.TITLE} description={WORK.DESCRIPTION}>
  <Container>
    <div class="space-y-10">
      <div class="animate font-semibold text-black dark:text-white">
        Work
      </div>

      <ul class="flex flex-col space-y-6">
        {
          groupedWork.map((group) => (
            <li class="animate border-t border-neutral-400 dark:border-neutral-500 pt-6 first:border-t-0 first:pt-0">
              {
                group.entries.length === 1
                  ? (
                    // --- Single role at this company: simple layout ---
                    <>
                      <div class="text-sm opacity-75">
                        {dateRange(
                          group.entries[0].data.dateStart,
                          group.entries[0].data.dateEnd
                        )}
                      </div>
                      <div class="font-semibold text-black dark:text-white">
                        {group.company}
                      </div>
                      <div class="text-sm opacity-75">
                        {group.entries[0].data.role}
                      </div>
                      <article class="mt-1">
                        <group.entries[0].Content />
                      </article>
                    </>
                  )
                  : (
                    // --- Multiple roles at this company: stacked / LinkedIn style ---
                    <>
                      {/* Company-wide date range */}
                      <div class="text-sm opacity-75">
                        {dateRange(group.companyStart, group.companyEnd)}
                      </div>

                      {/* Company name */}
                      <div class="font-semibold text-black dark:text-white">
                        {group.company}
                      </div>

                      {/* Stacked roles with timeline dots/lines */}
                      <ul class="mt-3 flex flex-col space-y-6">
                        {
                          group.entries.map((entry, index) => (
                            <li class="flex">
                              {/* Timeline column: smaller dot + line */}
                              <div class="mr-4 flex flex-col items-center">
                                <div class="h-2 w-2 mt-1 rounded-full bg-gray-500 dark:bg-neutral-400" />
                                {
                                  index !== group.entries.length - 1 && (
                                    <div class="mt-6 w-px flex-1 bg-neutral-300 dark:bg-neutral-700" />
                                  )
                                }
                              </div>

                              {/* Role content */}
                              <div class="flex-1">
                                <div class="text-sm opacity-75">
                                  {entry.data.role} Â· {dateRange(entry.data.dateStart, entry.data.dateEnd)}
                                </div>
                                <article class="mt-1">
                                  <entry.Content />
                                </article>
                              </div>
                            </li>
                          ))
                        }

                      </ul>
                    </>
                  )
              }
            </li>
          ))
        }
      </ul>
    </div>
  </Container>
</PageLayout>